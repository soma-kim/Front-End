<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>변수와 자료형</title>
</head>
<body>
    <h1>변수와 자료형</h1>

    <h3>* 변수 선언 시 var 뿐만 아니라 let, const도 사용 가능</h3>

    <h4>var, let, const의 차이점</h4>

    <h4>1)변수 선언 방식</h4>
    
    <button onclick="diffDeclare();">클릭</button>

    <script>
        function diffDeclare() {
            
            // var 변수명;
            // let 변수명;
            // const 변수명 = 값;

            // var: 변수의 중복 선언 가능, 재할당 가능
            var userId = "user01";
            console.log(userId);

            var userId = "user02"; // 변수의 중복 선언이 가능
            console.log(userId);

            userId = "user03"; // 대입(할당) 가능
            console.log(userId);
            
            console.log("----------");

            // let: 변수의 중복 선언 불가능, 재할당 가능
            let userPwd = "pass01";
            console.log(userPwd);

            // let userPwd = "pass02"; // 변수의 중복선언이 애초에 불가함 (자바의 변수와 같음)
            // console.log(userPwd);

            userPwd = "pass03";
            console.log(userPwd);

            console.log("----------");

            // const: 변수의 중복 선언 불가능, 재할당 불가능
            const age = 20
            console.log(age);

            // const age = 30; // 중복 선언이 애초에 안 됨 (자바의 변수와 동일)
            // console.log(age);

            age = 40; // 재대입(재할당) 불가 (값 변경이 불가하다 == 상수)
            console.log(age);

            /*
                var는 자유롭게 변수를 선언, 사용할 수 있다라는 장점이 있음
                단, 중복된 변수가 남발할 수 있고 실수로 인해 해당 변수에 내가 원하지 않는 값으로 덮어씌워질 수 있음
                => 보완돼서 나온 개념이 let, const

                let, const 사용을 권장 (회사 내규에 따르나 고루 쓸 줄 알아야 함)
            */
        }
    </script>

    <hr>

    <h4>2) 스코프(변수 사용 가능 영역)</h4>

    <button onclick="diffScope();">클릭</button>

    <script>
        function diffScope() {

            // var : functional scope => 변수가 선언된 "함수 영역" 안에서는 사용 가능
            if(true) {
                var age = 20;
            }
            console.log(age); // if문에서 선언한 변수를 if문 바깥에서도 쓸 수 있다

            for(var i = 0; i < 10; i++) {
                console.log(i);
            }
            console.log("반복문 끝남: " + i); // 10

            // let, const: block scope => 변수가 선언된 "블록 영역" 안에서만 사용 가능
            if(true) {
                let name = "홍길동";
                console.log(name);
            }
            console.log(name);

            for(let j = 0; j < 5; j++) { // const는 for문에서 원래 사용 불가! (증감식 때문)
                console.log(j);
            }
            console.log("반복문 끝남: " + j);

        }
    </script>

    <hr>

    <h3>* 변수 선언 위치에 따른 전역변수/지역변수</h3>

    <pre>
        &lt;script&gt;
            var 변수명; // 전역변수 (global)
            변수명; // 전역변수(global)

            function 함수명() {

                var 변수명; // 지역변수(local)
                변수명; // 지역변수가 아니다???

            }

        &lt;/script&gt;
    </pre>

    <script>

        // 전역변수들은 자동으로 window 객체의 필드로 등록됨
        str = "전역변수";
        var str2 = "var 전역변수";

        // 화면이 실행되자마자 함수가 실행되게끔 하고 싶음
        // 해당 이 html 문서가 브라우저상에 한 번 다 로딩되고 나서
        // 곧 바로 해당 함수가 한번 실행됨
        // window.onload : 해당 이 html 문서가 다 로딩되고 나서 곧 바로 실행할 함수를 지정하는 구문
        window.onload = function () {
            var str = "지역변수"; // 전역변수명과 중복
            var str = "새로운 지역변수";
            str4 = "난 뭘까요?";

            console.log("--- str ---");
            console.log(str); // 새로운 지역변수
                              // 지역변수명과 전역변수명이 동일한 경우 변수 호출 시 지역변수 호출
            // 전역변수에 접근하고자 할 경우에는? => window. 또는 this. 를 앞에 붙여 줌
            console.log(window.str);
            console.log(this.str);
        }






    </script>



</body>
</html>